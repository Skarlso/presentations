= Go's hidden #pragma
Dave Cheney <dave@cheney.net>
v1.0, April 15th, 2017

== Introduction

Hello!

My name is David.
I'm a software programmer and hardware enthusiast from Sydney, Australia.

This talk is about compiler directives; or as they are commonly known, _pragmas_. 

== A little history

Before we talk about Go, let's talk a little about the history of the pragma directive.

Many languages have the notion of a command, or directive that changes the way the source code is interpreted.

=== Perl

Perl has things like `use`

    use strict;
    use strict "vars";
    use strict "refs";
    use strict "subs";
    use strict;
    no strict "vars";

Which enable features, or make the compiler interpret the source of the program differently

http://perldoc.perl.org/index-pragmas.html

=== Javascript

Javascript is the same, ecmascript 5 extended the langauge with _optional_ modes like 

    "use strict";

Which enables "Strict Mode" when parsing your javascript source.

=== Rust

Rust is similar, they use their attributes and features syntax to enable _unstable_ features in the compiler or standard library

=== C

There are other examples from other languages, but C is the progenitor of the name pragma, because it comes from C's `#pragma` syntax.

The name comes from 

== Does Go have pragmas?

Now that we know a little bit of the history of p

You saw earlier that #pragma, like #include and #define are implemented in C style languages with a preprocessor.

== A word of warning

TODO find rant from Rob about compiler authors always adding pragmas

== They're actually called pragms in the source

// show link to https://github.com/golang/go/blob/master/src/cmd/compile/internal/gc/lex.go#L64
= Pragmas

here are the pragmas that are recognised in Go 1.8.
The list has changed over time, previous versions of Go understood a different set, and future versions of Go will understand a different set.

I won't go into the pragmas that were added in the past and have been dropped, you can leave that as an exercise for yourself.

== Syntax

The directives we're talking about today take a specific for

//xxx:directive

Where `xxx` is the word `go`, although you can see that the Go team were at least considering future growth, even though they don't encourage it.

It's also important to note that there is ++no space++ between the `//` and the `go` keyword. This is partly an accident of history, but it also makes it less likely to conflict with a regular comment.

Again, if you get this syntax wrong there is no checking--not even vet--and in most cases you code _will_ compile, but might be slower, or behave unreliably.

== go:noescape

Early in Go's life, the parts that went into a complete Go program would include Go code, obviously, some C code from the run time, and some assembly code, again from the runtime and also the syscall package.

The thing to take away from this was it was _expected_ that inside a package, you'd find functions which were _not_ implemented in Go.

Now, normally this wouldn't be a problem, except when they interacts with the escape analyser.

=== Escape analysis

Who knows what escape analysis is?

In Go it's very common to do somethign like this

   func NewThing() (*Thing) {
          t := Thing { Horses: 12, Goats: 9, Mice: 1000 }
          return &t
   }

That is, inside `NewThing` we declare and initalise a new `Thing` variable, then return the _address_ of `t`.

We do this so often inside Go it probably doesn't sink in that if you were to do something like this in C, the result would be massive memory corruption, because the address returned from `NewThing` would point to the location on the stack where `t` was temporariliy allocated.

Now, in Go, being a memory safe language, this construct is safe--the compiler recognises that the address of `t` will be used after the function returns and quietly arranges for `t` to be allocated on the heap, not the stack.
Technically we say that `t` escapes to the heap.
There are a few reasons why this happens, but returning the address of a variable is the most common.

Is everyone comfortable with this idea -- when the compiler sees that a variable's address will live beyond the lifetime of the function it is declared, the compiler moves the location where the variable is allocated from the stack to the heap.

Obviously there is a cost; heap allocated variables have to be garbage collected when they are no longer reachable, stack allocated variables are automatically free'd when their function returns.
Keep that in mind.

Now 
          

i've talked about escape analysis at previous prestnations so I'll just focus on this one part here.

escape analysis's job is to discover if a value escapes to the heap; that is, does it live longer than the lifetime of the function, so it cannot be stored on the stack.

show example of syscall.Read

talk about the throughput improvement

Can you use this in your code; only with asm that does the same thing as syscall. syscll. 

Note, you're buypassing the checks of the compiler, if you get this wrong you'll corrupt memory and no tool will be able to spot this

== go:norace

NFI

== go:nosplit

talk about the large amount of the runtime that was written in asm

talk about the TEXTFLAG asm pragmas

when the runtime was rewritten in Go, needed some way to say that a particular function

== go:noinline

https://go-review.googlesource.com/#/c/13911/

== go:systemstack

=== digression system stack vs goroutine stack

I'm not using the word native stack here because that is a matter of perspective.
From the POV of a goroutine, the system stack is foreign and it's own is native.
From the POV of the os thread, the goroutine's stack is opaque, and it

Sometimes in the runtime we need to run code that does not grow the stack, see nosplit, but can potentially use a lot of stack, or needs to run on the system thread because that is waht the underlying operation system expects.

== so

we used to have a trampoline function called system stack.
runs go code on the thread's native stack.

Now that the horse had truely bolted, the systemstack trampoline was rewritten to be a linker call with go:systemstack

== go:nowritebarrier

== go:nowritebarrierrec

== go:yeswritebarrierrec

== go:cgo_unsafe_args

== go:uintptrescapes
		// For the next function declared in the file
		// any uintptr arguments may be pointer values
		// converted to uintptr. This directive
		// ensures that the referenced allocated
		// object, if any, is retained and not moved
		// until the call completes, even though from
		// the types alone it would appear that the
		// object is no longer needed during the
		// call. The conversion to uintptr must appear
		// in the argument list.
		// Used in syscall/dll_windows.go.
		return UintptrEscapes

== go:notinheap

== is +build a pragma

One last thing, before we close.
Go, or more speifically the go tool, has its own form of conditinal compilation in the form of +build tags.

They follow their own rules, don't require `unsafe` 
i argue not

== Conclusion

Pragmas in Go have a rich history, and I hope the retelling of this history has been interesting to you.
They are used inside the runtime itself to gain a foothold to implement Go, including the garbage collector, in Go itself.
You find pragmas used, sparingly, inside the standard library, although you'll never find them in godoc.

Should you use these pragmas in your own programs?

Well, maybe.

Remember, magic comments are _not_ part of the language spec, if you use gopherjs, or llgo, or gccgo, your code will still compile, but may operate differently.
So i'll close with the words of Russ Cox, taken only slightly out of context

[quote, Russ Cox]
Again, not supported.  Sometimes that works, sometimes it doesn't. If it breaks you get to keep both pieces (for now).

https://groups.google.com/d/msg/golang-nuts/UoYT9Y8tRwE/_G8a9ooS-P4J

Thank you.

